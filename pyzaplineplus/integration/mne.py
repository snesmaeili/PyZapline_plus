"""MNE-Python integration helpers for pyzaplineplus.zapline_plus.

These wrappers provide thin glue so that Zapline-plus can operate on MNE-Python objects while respecting copy semantics, channel picks, and verbosity controls.
"""
from __future__ import annotations

from typing import TYPE_CHECKING, Any, Mapping, MutableMapping, Sequence

import numpy as np

from ..core import zapline_plus

if TYPE_CHECKING:  # pragma: no cover - imports only for type checkers
    import mne
    from mne.epochs import BaseEpochs
    from mne.io.base import BaseRaw


def _require_mne() -> "mne":
    try:
        import mne  # type: ignore
    except Exception as exc:  # pragma: no cover - kept for informative error
        raise ImportError(
            "pyzaplineplus MNE integration requires 'mne' to be installed. Install with\n"
            "    pip install pyzaplineplus[mne]\n"
            "or\n"
            "    pip install mne\n"
            "and re-run the function."
        ) from exc
    return mne


def _prepare_kwargs(
    line_freqs: Sequence[float] | str | None,
    zap_kwargs: Mapping[str, Any] | None,
) -> MutableMapping[str, Any]:
    params: MutableMapping[str, Any] = dict(zap_kwargs or {})
    if line_freqs is not None:
        params["noisefreqs"] = line_freqs
    params.setdefault("plotResults", False)
    return params


def _log_context(mne: "mne", verbose: bool | str | None):  # pragma: no cover - thin wrapper
    from contextlib import nullcontext

    if verbose is None:
        return nullcontext()
    from mne.utils import use_log_level

    if verbose is True:
        return use_log_level("INFO")
    if verbose is False:
        return use_log_level("WARNING")
    return use_log_level(verbose)  # type: ignore[arg-type]


def zapline_plus_raw(
    raw: "BaseRaw",
    *,
    picks: Sequence[str] | Sequence[int] | str | None = "data",
    copy: bool = True,
    line_freqs: Sequence[float] | str | None = "line",
    verbose: bool | str | None = None,
    **zap_kwargs: Any,
):
    """Clean an MNE Raw object with Zapline-plus.

    Parameters
    ----------
    raw : mne.io.BaseRaw
        The raw object to clean. Must be preloaded.
    picks : str | sequence | None
        Channels to clean. Follows the standard MNE pick semantics;
        the default "data" selects MNE data channels.
    copy : bool
        If True (default), operate on a copy of raw. If False, the
        cleaning is applied in place.
    line_freqs : sequence | "line" | None
        Frequencies to remove. The special value "line" follows the MATLAB
        zapline-plus heuristic of picking 50/60 Hz based on sampling rate and
        None disables frequency selection overrides.
    verbose : bool | str | None
        Temporary override for MNE's log level.
    **zap_kwargs : dict
        Extra keyword arguments forwarded to pyzaplineplus.zapline_plus.

    Returns
    -------
    raw_out : mne.io.BaseRaw
        Cleaned raw (copy if copy=True).
    config : dict
        Final Zapline-plus configuration used during cleaning.
    analytics : dict
        Analytics dictionary produced by Zapline-plus.
    figs : list of matplotlib.figure.Figure
        Figures generated by Zapline-plus (may be empty if plotting disabled).
    """
    mne = _require_mne()
    from mne.io.pick import _picks_to_idx

    if not getattr(raw, "preload", False):
        raise ValueError("raw must be preloaded (raw.preload must be True)")

    picks_idx = _picks_to_idx(raw.info, picks, none="data", exclude=())
    if picks_idx.size == 0:
        raise ValueError("No channels selected by 'picks'.")

    raw_out = raw.copy() if copy else raw
    data = raw_out.get_data(picks=picks_idx)
    orig_dtype = data.dtype

    fs = float(raw_out.info["sfreq"])
    zap_params = _prepare_kwargs(line_freqs, zap_kwargs)

    with _log_context(mne, verbose):
        clean_T, config, analytics, figs = zapline_plus(data.T, fs, **zap_params)

    clean = clean_T.T
    if clean.dtype != orig_dtype:
        clean = clean.astype(orig_dtype, copy=False)

    raw_out._data[picks_idx, :] = clean

    return raw_out, config, analytics, figs


def zapline_plus_epochs(
    epochs: "BaseEpochs",
    *,
    picks: Sequence[str] | Sequence[int] | str | None = "data",
    copy: bool = True,
    line_freqs: Sequence[float] | str | None = "line",
    verbose: bool | str | None = None,
    **zap_kwargs: Any,
):
    """Clean an MNE Epochs object with Zapline-plus.

    The epochs are vectorised across time while keeping per-channel structure so
    that the Zapline-plus algorithm operates on a contiguous view of the picked
    data. The cleaned data is reshaped back into epochs afterwards.

    Parameters
    ----------
    epochs : mne.BaseEpochs
        Epochs object to clean. Must be preloaded.
    picks : str | sequence | None
        Channels to clean (same semantics as zapline_plus_raw).
    copy : bool
        Whether to operate on a copy of epochs (default) or in place.
    line_freqs : sequence | "line" | None
        Frequencies to remove; forwarded to Zapline-plus.
    verbose : bool | str | None
        Temporary override for MNE's log level.
    **zap_kwargs : dict
        Additional Zapline-plus keyword arguments.

    Returns
    -------
    epochs_out : mne.BaseEpochs
        Cleaned epochs instance (copy if copy=True).
    config : dict
        Final Zapline-plus configuration dictionary.
    analytics : dict
        Analytics dictionary from Zapline-plus.
    figs : list of matplotlib.figure.Figure
        Figures generated by Zapline-plus (may be empty).
    """
    mne = _require_mne()
    from mne.io.pick import _picks_to_idx

    if not getattr(epochs, "preload", False):
        raise ValueError("epochs must be preloaded (epochs.preload must be True)")

    picks_idx = _picks_to_idx(epochs.info, picks, none="data", exclude=())
    if picks_idx.size == 0:
        raise ValueError("No channels selected by 'picks'.")

    epochs_out = epochs.copy() if copy else epochs
    data_view = epochs_out._data[:, picks_idx, :]
    orig_dtype = data_view.dtype

    n_epochs, n_picks, n_times = data_view.shape
    reshaped = data_view.transpose(0, 2, 1).reshape(n_epochs * n_times, n_picks)

    fs = float(epochs_out.info["sfreq"])
    zap_params = _prepare_kwargs(line_freqs, zap_kwargs)

    with _log_context(mne, verbose):
        clean_flat, config, analytics, figs = zapline_plus(reshaped, fs, **zap_params)

    clean = clean_flat.reshape(n_epochs, n_times, n_picks).transpose(0, 2, 1)
    if clean.dtype != orig_dtype:
        clean = clean.astype(orig_dtype, copy=False)

    epochs_out._data[:, picks_idx, :] = clean

    return epochs_out, config, analytics, figs


# Backward-compatible alias kept for older imports
apply_zapline_to_raw = zapline_plus_raw

